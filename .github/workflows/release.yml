name: Release

on:
  push:
    tags:
      - '*'
  workflow_dispatch:
    inputs:
      dry-run:
        description: 'Perform a dry run (build wheels but do not publish)'
        type: boolean
        default: false

jobs:
  build-wheels:
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux builds - matching polars deployment targets
          - os: ubuntu-latest
            system: x86_64-linux
            build_type: native
          - os: ubuntu-latest
            system: aarch64-linux
            build_type: cross-compiled
            
          # macOS builds - matching polars deployment targets
          - os: macos-13  # Intel - matches polars' macosx_10_12_x86_64
            system: x86_64-darwin
            build_type: native
          - os: macos-latest  # ARM64 - matches polars' macosx_11_0_arm64  
            system: aarch64-darwin
            build_type: native
            
    runs-on: ${{ matrix.os }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up QEMU for cross-compilation
        if: matrix.build_type == 'cross-compiled'
        uses: docker/setup-qemu-action@v3
        with:
          platforms: linux/arm64

      - name: Setup Nix
        uses: ./.github/actions/setup-nix

      - name: Set up Rust toolchain
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          target: ${{ matrix.build_type == 'cross-compiled' && matrix.system == 'aarch64-linux' && 'aarch64-unknown-linux-gnu' || '' }}

      - name: Build ht binary portably
        run: |
          echo "ü¶Ä Building portable ht binary"
          
          # Get ht source from Nix input
          HT_SOURCE=$(nix eval --impure --raw --expr '(builtins.getFlake (toString ./.)).inputs.ht.outPath')
          
          # Build ht binary using standard Rust toolchain
          cd "$HT_SOURCE"
          
          if [ "${{ matrix.build_type }}" = "cross-compiled" ]; then
            echo "üîÄ Cross-compiling for ${{ matrix.system }}"
            cargo build --release --target ${{ matrix.system == 'aarch64-linux' && 'aarch64-unknown-linux-gnu' || matrix.system }}
            HT_BINARY="target/${{ matrix.system == 'aarch64-linux' && 'aarch64-unknown-linux-gnu' || matrix.system }}/release/ht"
          else
            echo "üè† Building natively"
            cargo build --release 
            HT_BINARY="target/release/ht"
          fi
          
          # Copy binary to workspace
          mkdir -p "$GITHUB_WORKSPACE/ht-binary"
          cp "$HT_BINARY" "$GITHUB_WORKSPACE/ht-binary/ht"
          chmod +x "$GITHUB_WORKSPACE/ht-binary/ht"
          
          echo "‚úÖ Built portable binary:"
          file "$GITHUB_WORKSPACE/ht-binary/ht"

      - name: Build Python wheel
        run: |
          echo "üêç Building Python wheel with bundled binary"
          
          # Create build directory
          mkdir -p build
          cd build
          
          # Copy Python source
          cp -r ../src .
          cp ../pyproject.toml .
          cp ../README.md .
          
          # Bundle the ht binary
          mkdir -p src/htty/_bundled
          cp ../ht-binary/ht src/htty/_bundled/ht
          
          # Build wheel using standard Python tools
          python -m pip install build
          python -m build --wheel --outdir ../dist
          
          # List built wheels
          echo "üì¶ Built wheels:"
          ls -la ../dist/

      - name: Test cross-compiled wheel
        if: matrix.build_type == 'cross-compiled'
        run: |
          echo "üß™ Testing cross-compiled wheel in target platform container"
          WHEEL_PATH=$(ls dist/*.whl | head -1)
          WHEEL_NAME=$(basename "$WHEEL_PATH")
          
          docker run --rm --platform linux/arm64 \
            -v "$(pwd)/dist:/test" \
            python:3.11-slim \
            bash -c "
              echo 'üîß Installing cross-compiled wheel...' && \
              pip install /test/$WHEEL_NAME && \
              echo '‚úÖ Installation successful' && \
              \
              echo 'üîß Testing Python import...' && \
              python -c 'import htty; print(\"‚úÖ Import successful\")' && \
              \
              echo 'üîß Checking bundled binary exists...' && \
              python -c 'import htty; import os; ht_path = os.path.join(os.path.dirname(htty.__file__), \"bin\", \"ht\"); print(f\"Binary at: {ht_path}\"); print(f\"Exists: {os.path.exists(ht_path)}\"); print(f\"Executable: {os.access(ht_path, os.X_OK) if os.path.exists(ht_path) else False}\")' && \
              \
              echo 'üîß Checking binary architecture...' && \
              python -c 'import htty; import os, subprocess; ht_path = os.path.join(os.path.dirname(htty.__file__), \"bin\", \"ht\"); result = subprocess.run([\"file\", ht_path], capture_output=True, text=True); print(f\"Architecture: {result.stdout.strip()}\")' && \
              \
              echo 'üîß Testing CLI availability (htty-ht console script should exist)...' && \
              which htty-ht > /dev/null && echo '‚úÖ htty-ht console script found' || echo '‚ùå htty-ht console script missing' && \
              \
              echo 'üéâ Cross-compiled wheel validation complete!' && \
              echo 'üìù Binary built with portable toolchain (maturin/cargo)' && \
              echo '‚úÖ Should work on any compatible Linux system without Nix'
            "

      - name: Copy and verify wheel
        run: |
          # Find the built wheel
          WHEEL_PATH=$(ls dist/*.whl | head -1)
          WHEEL_NAME=$(basename "$WHEEL_PATH")
          
          echo "üì¶ Built wheel: $WHEEL_NAME"
          ls -lh dist/
          
          echo "üéØ Target system: ${{ matrix.system }}"
          echo "üîÑ Build type: ${{ matrix.build_type }}"

      - name: Upload wheel
        uses: actions/upload-artifact@v4
        with:
          name: wheel-${{ matrix.system }}
          path: "dist/*.whl"

  publish-to-pypi:
    needs: build-wheels
    runs-on: ubuntu-latest
    environment: release
    permissions:
      id-token: write  # For trusted publishing
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Nix
        uses: ./.github/actions/setup-nix

      - name: Create packages directory
        run: mkdir -p packages/

      - name: Build source distribution
        run: |
          nix build .#htty-sdist
          cp result/*.tar.gz packages/

      - name: Download all wheels
        uses: actions/download-artifact@v4
        with:
          pattern: wheel-*
          path: packages/
          merge-multiple: true

      - name: Verify packages for publication
        run: |
          echo "üì¶ Packages to be published:"
          ls -la packages/
          
          WHEEL_COUNT=$(ls packages/*.whl 2>/dev/null | wc -l)
          SDIST_COUNT=$(ls packages/*.tar.gz 2>/dev/null | wc -l)
          
          echo "   Wheels: $WHEEL_COUNT"
          echo "   Source distributions: $SDIST_COUNT"
          
          if [ "$WHEEL_COUNT" -eq 0 ]; then
            echo "‚ùå ERROR: No wheels found"
            exit 1
          fi
          
          if [ "$SDIST_COUNT" -eq 0 ]; then
            echo "‚ùå ERROR: No source distribution found"
            exit 1
          fi
          
          echo "‚úÖ All packages ready for publication"

      - name: Publish to PyPI
        if: ${{ !inputs.dry-run }}
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          packages-dir: packages/

      - name: Dry run complete
        if: ${{ inputs.dry-run }}
        run: |
          echo "üèÅ Dry run complete - packages built but not published"
          echo "To publish for real, create a release tag or run workflow without dry-run" 