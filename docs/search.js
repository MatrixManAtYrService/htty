window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "htty", "modulename": "htty", "kind": "module", "doc": "<p>htty - a wrapper around <a href=\"https://github.com/andyk/ht\">ht</a></p>\n\n<p>Some terminal applications don't make it easy to capture their output in a human-readable way.\nHere's vim's startup screen:</p>\n\n<pre><code>~                       VIM - Vi IMproved\n~                       version 9.1.1336\n~                   by Bram Moolenaar et al.\n~          Vim is open source and freely distributable\n~\n~                 Help poor children in Uganda!\n</code></pre>\n\n<p>If you capture vim's ouput directly, you won't get the nicely formatted text you see above.\nInstead, you'll get raw ANSI escape sequences.</p>\n\n<pre><code>Vi IMproved\u001b[6;37Hversion 9.0.2136\u001b[7;33Hby Bram Moolenaar et al.\u001b[8;24HVim is open source and freely distributable\u001b[10;32HHelp poor children in Uganda!\n</code></pre>\n\n<p>htty makes it possible to get a human-friendly string representing the contents of a terminal, without having an actual graphical terminal emulator in the loop.</p>\n\n<p>To do this, it connects processes (like vim) to a <a href=\"https://man7.org/linux/man-pages/man7/pty.7.html\">pseudoterminal interface</a> which directs output to an ANSI interpreter.\nMost ANSI interpreters are involved with putting characters on a screen for humans to view directly, but this one is headless, so the text is stored internally for later reference.</p>\n\n<p>htty lets you control the underlying process and take snapshots of the headless terminal's contents at times when you expect it to be interesting.\nThis can be handy for testing, like when you want to assert that the user's terminal looks a certain way.</p>\n\n<h1 id=\"library-usage\">Library Usage</h1>\n\n<p>The <code>terminal_session</code> context manager yields a <code>HtWrapper</code> object which has methods for communicating with the underlying <code>ht</code> process.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">htty</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Press</span><span class=\"p\">,</span> <span class=\"n\">terminal_session</span>\n\n<span class=\"c1\"># start an interactive bourne shell in a small headless terminal</span>\n<span class=\"k\">with</span> <span class=\"n\">terminal_session</span><span class=\"p\">(</span><span class=\"s2\">&quot;sh -i&quot;</span><span class=\"p\">,</span> <span class=\"n\">rows</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"n\">cols</span><span class=\"o\">=</span><span class=\"mi\">6</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">sh</span><span class=\"p\">:</span>\n\n    <span class=\"c1\"># print enough so that the prompt is at the bottom of the screen</span>\n    <span class=\"n\">sh</span><span class=\"o\">.</span><span class=\"n\">send_keys</span><span class=\"p\">([</span><span class=\"sa\">r</span><span class=\"s2\">&quot;printf &#39;\\n\\n\\n\\nhello world\\n&#39;&quot;</span><span class=\"p\">,</span> <span class=\"n\">Press</span><span class=\"o\">.</span><span class=\"n\">ENTER</span><span class=\"p\">])</span>\n    <span class=\"n\">sh</span><span class=\"o\">.</span><span class=\"n\">expect</span><span class=\"p\">(</span><span class=\"s2\">&quot;world&quot;</span><span class=\"p\">)</span>\n    <span class=\"n\">hello</span> <span class=\"o\">=</span> <span class=\"n\">sh</span><span class=\"o\">.</span><span class=\"n\">snapshot</span><span class=\"p\">()</span>\n\n    <span class=\"c1\"># clear the terminal</span>\n    <span class=\"n\">sh</span><span class=\"o\">.</span><span class=\"n\">send_keys</span><span class=\"p\">([</span><span class=\"s2\">&quot;clear&quot;</span><span class=\"p\">,</span> <span class=\"n\">Press</span><span class=\"o\">.</span><span class=\"n\">ENTER</span><span class=\"p\">])</span>\n    <span class=\"n\">sh</span><span class=\"o\">.</span><span class=\"n\">expect_absent</span><span class=\"p\">(</span><span class=\"s2\">&quot;world&quot;</span><span class=\"p\">)</span>\n    <span class=\"n\">sh</span><span class=\"o\">.</span><span class=\"n\">expect</span><span class=\"p\">(</span><span class=\"s2\">&quot;\\$&quot;</span><span class=\"p\">)</span>\n    <span class=\"n\">cleared</span> <span class=\"o\">=</span> <span class=\"n\">sh</span><span class=\"o\">.</span><span class=\"n\">snapshot</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># assert correct placement</span>\n<span class=\"k\">assert</span> <span class=\"n\">hello</span><span class=\"o\">.</span><span class=\"n\">text</span> <span class=\"o\">==</span> <span class=\"s1\">&#39;</span><span class=\"se\">\\n</span><span class=\"s1\">&#39;</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">([</span>\n    <span class=\"s2\">&quot;      &quot;</span><span class=\"p\">,</span> <span class=\"c1\"># line wrap after 6 chars</span>\n    <span class=\"s2\">&quot;hello &quot;</span><span class=\"p\">,</span>\n    <span class=\"s2\">&quot;world &quot;</span><span class=\"p\">,</span>\n    <span class=\"s2\">&quot;$     &quot;</span><span class=\"p\">,</span> <span class=\"c1\"># four rows high</span>\n<span class=\"p\">])</span>\n\n<span class=\"c1\"># assert that clear... cleared</span>\n<span class=\"k\">assert</span> <span class=\"n\">cleared</span><span class=\"o\">.</span><span class=\"n\">text</span> <span class=\"o\">==</span> <span class=\"s1\">&#39;</span><span class=\"se\">\\n</span><span class=\"s1\">&#39;</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">([</span>\n    <span class=\"s2\">&quot;$     &quot;</span><span class=\"p\">,</span>\n    <span class=\"s2\">&quot;      &quot;</span><span class=\"p\">,</span>\n    <span class=\"s2\">&quot;      &quot;</span><span class=\"p\">,</span>\n    <span class=\"s2\">&quot;      &quot;</span><span class=\"p\">,</span>\n<span class=\"p\">])</span>\n</code></pre>\n</div>\n\n<p>It's a good idea to <code>expect</code> something before you take a snapshot, otherwise the snapshot might happen before the child process has fully arrived at the state you're trying to capture.</p>\n\n<h1 id=\"command-line-usage\">Command Line Usage</h1>\n\n<p>Unlike the <code>htty</code> python library, the <code>htty</code> command accepts all of its instructions before it starts.\nIt will</p>\n\n<pre><code>1. run them all, printing snapshots along the way\n2. terminate the child process\n3. exit\n</code></pre>\n\n<p>If you're looking for something that doesn't clean the process up afterwards, consider one of these:</p>\n\n<ul>\n<li>run <code>ht</code> instead of <code>htty</code> in a shell (<a href=\"https://github.com/andyk/ht?tab=readme-ov-file#usage\">usage</a>)</li>\n<li>use <code>htty</code> as a python library</li>\n<li>other terminal emulator libraries such as <a href=\"https://github.com/selectel/pyte\">pyte</a></li>\n</ul>\n\n<pre><code>$ htty --help\n# DOCS_OUTPUT: htty --help\n</code></pre>\n\n<p>The <code>sl</code> command animates an ascii-art train engine driving from right to left across your terminal.\nNear the middle of the engine are some <code>I</code>'s an further back is a <code>Y</code>.\n<code>htty</code> can use the appearance and dissapearance of these characters to trigger snapshots of the train.</p>\n\n<p>The command below wraps <code>sl</code>, and captures two snapshots (triggered by Y appearing and I dissapering).\n ints them to stdout with a '----' to indicate the end of each snapshot.</p>\n\n<pre><code>$ htty -r 15 -c 50 --expect Y --snapshot --expect-absent I --snapshot -- sl\n\n                    (@@@)\n                 ====        ________\n             _D _|  |_______/        \\__I_I_____==\n              |(_)---  |   H\\________/ |   |\n              /     |  |   H  |  |     |   |\n             |      |  |   H  |__-----------------\n             | ________|___H__/__|_____/[][]~\\____\n             |/ |   |-----------I_____I [][] []  D\n           __/ =| o |=-~~\\  /~~\\  /~~\\  /~~\\ ____Y\n            |/-=|___|=   O=====O=====O=====O|_____\n             \\_/      \\__/  \\__/  \\__/  \\__/\n\n\n\n----\n\n\n      ___________\n_===__|_________|\n     =|___ ___|      _________________\n      ||_| |_||     _|                \\_____A\n------| [___] |   =|                        |\n______|       |   -|                        |\n  D   |=======|____|________________________|_\n__Y___________|__|__________________________|_\n___/~\\___/          |_D__D__D_|  |_D__D__D_|\n   \\_/               \\_/   \\_/    \\_/   \\_/\n\n\n\n----\n</code></pre>\n\n<p>Warning: if you don't include an <code>--expect</code>, it's likely that your first snapshot will be empty because it happens before the command can get around to producing any output.</p>\n"}, {"fullname": "htty.terminal_session", "modulename": "htty", "qualname": "terminal_session", "kind": "function", "doc": "<p>The terminal_session context manager is a wrapper around <code>run</code> which ensures that the underlying process\ngets cleaned up:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"k\">with</span> <span class=\"n\">terminal_session</span><span class=\"p\">(</span><span class=\"s2\">&quot;some command&quot;</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">proc</span><span class=\"p\">:</span>\n    <span class=\"c1\"># interact with the running command here</span>\n    <span class=\"k\">assert</span> <span class=\"n\">proc</span><span class=\"o\">.</span><span class=\"n\">exit_code</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span>\n    <span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">proc</span><span class=\"o\">.</span><span class=\"n\">snapshot</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># htty terminates your command on context exit</span>\n<span class=\"k\">assert</span> <span class=\"n\">proc</span><span class=\"o\">.</span><span class=\"n\">exit_code</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span>\n<span class=\"k\">assert</span> <span class=\"s2\">&quot;hello world&quot;</span> <span class=\"ow\">in</span> <span class=\"n\">proc</span><span class=\"o\">.</span><span class=\"n\">snapshot</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n\n<p>Its usage is otherwise the same as <code>run</code>.\nIt also returns a</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">command</span><span class=\"p\">:</span> <span class=\"n\">Annotated</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]],</span> <span class=\"s1\">&#39;run this command (as a subprocess of ht)&#39;</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">rows</span><span class=\"p\">:</span> <span class=\"n\">Annotated</span><span class=\"p\">[</span><span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"s1\">&#39;number of rows for the headless terminal (default: 30)&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cols</span><span class=\"p\">:</span> <span class=\"n\">Annotated</span><span class=\"p\">[</span><span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"s1\">&#39;number of columns for the headless terminal (default: 60)&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">logger</span><span class=\"p\">:</span> <span class=\"n\">Annotated</span><span class=\"p\">[</span><span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">Logger</span><span class=\"p\">],</span> <span class=\"s1\">&#39;callers can override the default logger with their own&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">extra_subscribes</span><span class=\"p\">:</span> <span class=\"n\">Annotated</span><span class=\"p\">[</span><span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">htty_core</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">HtEvent</span><span class=\"p\">]],</span> <span class=\"s1\">&#39;additional event types to subscribe to&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Iterator</span><span class=\"p\">[</span><span class=\"n\">htty</span><span class=\"o\">.</span><span class=\"n\">ht</span><span class=\"o\">.</span><span class=\"n\">HtWrapper</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "htty.run", "modulename": "htty", "qualname": "run", "kind": "function", "doc": "<p>As a user of the htty python library, your code will run in the python process at the root of this\nprocess tree:</p>\n\n<pre><code>python '{/path/to/your/code.py}'\n\u2514\u2500\u2500 ht\n    \u2514\u2500\u2500 sh -c '{modified command}'\n</code></pre>\n\n<p>So if you're using htty to wrap vim, the process tree is:</p>\n\n<pre><code>python\n\u2514\u2500\u2500 ht\n    \u2514\u2500\u2500 sh\n        \u2514\u2500\u2500 vim\n</code></pre>\n\n<p>For reasons that are documented in <a href=\"./htty-core/htty_core.html#run\">htty-core</a>, the command that ht\nruns is not:</p>\n\n<pre><code>sh -c '{command}'\n</code></pre>\n\n<p>Instead it's something like this:</p>\n\n<pre><code>sh -c '{command} ; exit_code=$? ; /path/to/ht wait-exit /path/to/tmp/ht_fifo_5432 ; exit $exit_code'\n</code></pre>\n\n<p>This function invokes <code>ht</code> as a subprocess such that you end up with a process tree like the one shown\nabove. It returns an <code>HtWrapper</code> object which can be used to interact with ht and its child process.</p>\n\n<p>It's up to you to clean up this process when you're done:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">proc</span> <span class=\"o\">=</span> <span class=\"n\">run</span><span class=\"p\">(</span><span class=\"s2\">&quot;some command&quot;</span><span class=\"p\">)</span>\n<span class=\"c1\"># do stuff</span>\n<span class=\"n\">proc</span><span class=\"o\">.</span><span class=\"n\">exit</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n\n<p>If you'd rather not risk having a bunch of <code>ht</code> processes lying around and wasting CPU cycles,\nconsider using the <code>terminal_session</code> instead.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">command</span><span class=\"p\">:</span> <span class=\"n\">Annotated</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]],</span> <span class=\"s1\">&#39;run this command (as a subprocess of ht)&#39;</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">rows</span><span class=\"p\">:</span> <span class=\"n\">Annotated</span><span class=\"p\">[</span><span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"s1\">&#39;number of rows for the headless terminal (default: 30)&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cols</span><span class=\"p\">:</span> <span class=\"n\">Annotated</span><span class=\"p\">[</span><span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"s1\">&#39;number of columns for the headless terminal (default: 60)&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">no_exit</span><span class=\"p\">:</span> <span class=\"n\">Annotated</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"s2\">&quot;whether to keep ht running even after the underlying command exits</span><span class=\"se\">\\n</span><span class=\"s2\">allows the caller to take snapshots even after the command has completed</span><span class=\"se\">\\n</span><span class=\"s2\">requires the caller to send an explicit &#39;exit&#39; event to cause ht to exit</span><span class=\"se\">\\n</span><span class=\"s2\">&quot;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">logger</span><span class=\"p\">:</span> <span class=\"n\">Annotated</span><span class=\"p\">[</span><span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">Logger</span><span class=\"p\">],</span> <span class=\"s1\">&#39;callers can override the default logger with their own&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">extra_subscribes</span><span class=\"p\">:</span> <span class=\"n\">Annotated</span><span class=\"p\">[</span><span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">htty_core</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">HtEvent</span><span class=\"p\">]],</span> <span class=\"s1\">&#39;additional event types to subscribe to&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">htty</span><span class=\"o\">.</span><span class=\"n\">ht</span><span class=\"o\">.</span><span class=\"n\">HtWrapper</span>:</span></span>", "funcdef": "def"}, {"fullname": "htty.HtWrapper", "modulename": "htty", "qualname": "HtWrapper", "kind": "class", "doc": "<p>A wrapper around a process started with the 'ht' tool that provides\nmethods for interacting with the process and capturing its output.</p>\n"}, {"fullname": "htty.HtWrapper.ht", "modulename": "htty", "qualname": "HtWrapper.ht", "kind": "variable", "doc": "<p></p>\n", "annotation": ": htty.proc.ProcessController"}, {"fullname": "htty.HtWrapper.cmd", "modulename": "htty", "qualname": "HtWrapper.cmd", "kind": "variable", "doc": "<p></p>\n", "annotation": ": htty.proc.ProcessController"}, {"fullname": "htty.HtWrapper.get_output", "modulename": "htty", "qualname": "HtWrapper.get_output", "kind": "function", "doc": "<p>Return list of output events.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "htty.HtWrapper.send_keys", "modulename": "htty", "qualname": "HtWrapper.send_keys", "kind": "function", "doc": "<p>Send keys to the terminal.</p>\n\n<p>Since we use --wait-for-output, this is much more reliable than the original.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">keys</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">htty</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"o\">.</span><span class=\"n\">Press</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">htty</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"o\">.</span><span class=\"n\">Press</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]]]</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "htty.HtWrapper.snapshot", "modulename": "htty", "qualname": "HtWrapper.snapshot", "kind": "function", "doc": "<p>Take a snapshot of the terminal output.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">timeout</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">5.0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">htty</span><span class=\"o\">.</span><span class=\"n\">ht</span><span class=\"o\">.</span><span class=\"n\">SnapshotResult</span>:</span></span>", "funcdef": "def"}, {"fullname": "htty.HtWrapper.exit", "modulename": "htty", "qualname": "HtWrapper.exit", "kind": "function", "doc": "<p>Exit the ht process, ensuring clean shutdown.</p>\n\n<p>Uses different strategies based on subprocess state:</p>\n\n<ul>\n<li>If subprocess already exited (exitCode event received): graceful shutdown via exit command</li>\n<li>If subprocess still running: forced termination with SIGTERM then SIGKILL</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">timeout</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">5.0</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "htty.HtWrapper.expect", "modulename": "htty", "qualname": "HtWrapper.expect", "kind": "function", "doc": "<p>Wait for a regex pattern to appear in the terminal output.</p>\n\n<p>This method efficiently waits for output by monitoring the output events from\nthe ht process rather than polling with snapshots. It checks both the current\nterminal state (via snapshot) and any new output that arrives.</p>\n\n<p>Args:\n    pattern: The regex pattern to look for in the terminal output\n    timeout: Maximum time to wait in seconds (default: 5.0)</p>\n\n<p>Raises:\n    TimeoutError: If the pattern doesn't appear within the timeout period\n    RuntimeError: If the ht process has exited</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pattern</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">timeout</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">5.0</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "htty.HtWrapper.expect_absent", "modulename": "htty", "qualname": "HtWrapper.expect_absent", "kind": "function", "doc": "<p>Wait for a regex pattern to disappear from the terminal output.</p>\n\n<p>This method efficiently waits for output changes by monitoring the output events\nfrom the ht process rather than polling with snapshots. It periodically checks\nthe terminal state to verify the pattern is gone.</p>\n\n<p>Args:\n    pattern: The regex pattern that should disappear from the terminal output\n    timeout: Maximum time to wait in seconds (default: 5.0)</p>\n\n<p>Raises:\n    TimeoutError: If the pattern doesn't disappear within the timeout period\n    RuntimeError: If the ht process has exited</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pattern</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">timeout</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">5.0</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "htty.ProcessController", "modulename": "htty", "qualname": "ProcessController", "kind": "class", "doc": "<p>Protocol for process manipulation operations.</p>\n", "bases": "typing.Protocol"}, {"fullname": "htty.ProcessController.__init__", "modulename": "htty", "qualname": "ProcessController.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "htty.ProcessController.exit", "modulename": "htty", "qualname": "ProcessController.exit", "kind": "function", "doc": "<p>Exit the process.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">timeout</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "htty.ProcessController.terminate", "modulename": "htty", "qualname": "ProcessController.terminate", "kind": "function", "doc": "<p>Terminate the process.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "htty.ProcessController.kill", "modulename": "htty", "qualname": "ProcessController.kill", "kind": "function", "doc": "<p>Force kill the process.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "htty.ProcessController.wait", "modulename": "htty", "qualname": "ProcessController.wait", "kind": "function", "doc": "<p>Wait for the process to finish.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">timeout</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "htty.ProcessController.poll", "modulename": "htty", "qualname": "ProcessController.poll", "kind": "function", "doc": "<p>Check if the process is still running.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "htty.ProcessController.pid", "modulename": "htty", "qualname": "ProcessController.pid", "kind": "variable", "doc": "<p>Get the process ID.</p>\n", "annotation": ": Optional[int]"}, {"fullname": "htty.ProcessController.exit_code", "modulename": "htty", "qualname": "ProcessController.exit_code", "kind": "variable", "doc": "<p>Get the exit code of the process.</p>\n", "annotation": ": Optional[int]"}, {"fullname": "htty.ProcessController.completed", "modulename": "htty", "qualname": "ProcessController.completed", "kind": "variable", "doc": "<p>Check if the process has completed.</p>\n", "annotation": ": bool"}, {"fullname": "htty.SnapshotResult", "modulename": "htty", "qualname": "SnapshotResult", "kind": "class", "doc": "<p>Result of taking a terminal snapshot</p>\n"}, {"fullname": "htty.SnapshotResult.__init__", "modulename": "htty", "qualname": "SnapshotResult.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">html</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">raw_seq</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span>)</span>"}, {"fullname": "htty.SnapshotResult.text", "modulename": "htty", "qualname": "SnapshotResult.text", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "htty.SnapshotResult.html", "modulename": "htty", "qualname": "SnapshotResult.html", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "htty.SnapshotResult.raw_seq", "modulename": "htty", "qualname": "SnapshotResult.raw_seq", "kind": "variable", "doc": "<p></p>\n"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();